// Generated by CoffeeScript 1.10.0
(function() {
  var FS, File, FileBase, PATH, SyncAppend, crypto;

  FileBase = require('./file');

  FS = require('fs');

  PATH = require('path');

  crypto = require('crypto');

  File = (function() {
    function File(base) {
      this.base = base;
    }

    File.prototype.append = function(str) {
      return this.base.append(str);
    };

    File.prototype.isClosed = function() {
      return this.base.closed;
    };

    File.prototype.getPath = function() {
      return this.base.path;
    };

    return File;

  })();

  SyncAppend = (function() {
    function SyncAppend(journalPath, files) {
      var base, dir, encoding, id, obj, p;
      this.journalPath = PATH.normalize(journalPath);
      this.fdJournalDir = null;
      dir = PATH.resolve(this.journalPath, '..');
      try {
        this.fdJournalDir = FS.openSync(dir, 'r');
      } catch (undefined) {}
      this.files = {};
      this.stopped = true;
      this.closed = false;
      this._recover();
      if (files == null) {
        files = {};
      }
      for (id in files) {
        obj = files[id];
        if (this.files[id] == null) {
          p = encoding = null;
          if ('string' === typeof obj) {
            p = obj;
          } else {
            p = obj.path;
            if (obj.encoding != null) {
              encoding = obj.encoding;
            }
          }
          p = PATH.normalize(p);
          base = new FileBase(p, encoding);
          this.files[id] = {
            path: p,
            base: base,
            file: new File(base)
          };
        }
      }
    }

    SyncAppend.prototype._recover = function() {
      var base, data, dir, error, exists, fd, fdDir, hash, hash2, id, log, obj, recovered, stat;
      data = null;
      try {
        data = FS.readFileSync(this.journalPath, {
          encoding: "utf8"
        });
      } catch (error) {
        return false;
      }
      recovered = false;
      hash = data.substr(0, 32);
      data = data.substr(32);
      hash2 = crypto.createHash('md5').update(data, "utf8").digest("hex");
      if (hash === hash2) {
        log = JSON.parse(data);
        for (id in log) {
          obj = log[id];
          exists = false;
          try {
            FS.accessSync(obj.path, FS.F_OK);
            exists = true;
          } catch (undefined) {}
          if (exists === false) {
            if (obj.size > 0) {
              throw new Error("Trying to recover a non-existing file " + obj.path + " to the file size " + obj.size);
            }
          } else {
            stat = FS.statSync(obj.path);
            if (stat.size < obj.size) {
              throw new Error("Trying to recover a corrupted file " + obj.path + " having file\nsize " + stat.size + " to file size " + obj.size);
            }
            dir = PATH.resolve(obj.path, '..');
            fdDir = null;
            try {
              fdDir = FS.openSync(dir, 'r');
            } catch (undefined) {}
            if (obj.size === 0) {
              FS.unlinkSync(obj.path);
              if (fdDir != null) {
                try {
                  FS.fsyncSync(fdDir);
                } catch (undefined) {}
              }
            } else {
              fd = FS.openSync(obj.path, 'r+');
              FS.ftruncateSync(fd, obj.size);
              FS.fsyncSync(fd);
              FS.closeSync(fd);
              if (fdDir != null) {
                try {
                  FS.fsyncSync(fdDir);
                } catch (undefined) {}
              }
            }
            if (fdDir != null) {
              FS.closeSync(fdDir);
            }
          }
        }
        recovered = true;
        for (id in log) {
          obj = log[id];
          base = new FileBase(obj.path, obj.encoding);
          this.files[id] = {
            path: obj.path,
            base: base,
            file: new File(base)
          };
        }
      }
      FS.unlinkSync(this.journalPath);
      if (this.fdJournalDir != null) {
        try {
          FS.fsyncSync(this.fdJournalDir);
        } catch (undefined) {}
      }
      return recovered;
    };

    SyncAppend.prototype.start = function(files) {
      var base, encoding, id, o, obj, p, ref;
      if (this.stopped === false || this.closed === true) {
        return false;
      }
      if (files != null) {
        for (id in files) {
          obj = files[id];
          p = encoding = null;
          if ('string' === typeof obj) {
            p = obj;
          } else {
            p = obj.path;
            encoding = obj.encoding;
          }
          if (this.files[id] != null) {
            o = this.files[id];
            o.base.changePath(p, encoding);
            o.path = p;
          } else {
            base = new FileBase(p, encoding);
            this.files[id] = {
              path: p,
              base: base,
              file: new File(base)
            };
          }
        }
      }
      this._initJournal();
      ref = this.files;
      for (id in ref) {
        obj = ref[id];
        obj.base.stopped = false;
      }
      this.stopped = false;
      return true;
    };

    SyncAppend.prototype._initJournal = function() {
      var data, error, fd, hash, id, log, obj, ref, size, stat, str;
      if (this.stopped === false) {
        return false;
      }
      log = {};
      ref = this.files;
      for (id in ref) {
        obj = ref[id];
        size = null;
        try {
          FS.accessSync(obj.path, FS.F_OK);
        } catch (error) {
          size = 0;
        }
        if (size == null) {
          stat = FS.statSync(obj.path);
          size = stat.size;
        }
        log[id] = {
          path: obj.path,
          size: size,
          encoding: obj.base.encoding
        };
      }
      str = JSON.stringify(log);
      hash = crypto.createHash('md5').update(str, "utf8").digest("hex");
      data = [hash, str].join('');
      fd = FS.openSync(this.journalPath, 'w');
      FS.writeSync(fd, data, 0, "utf8");
      FS.fsyncSync(fd);
      FS.closeSync(fd);
      if (this.fdJournalDir != null) {
        try {
          FS.fsyncSync(this.fdJournalDir);
        } catch (undefined) {}
      }
      return true;
    };

    SyncAppend.prototype.sync = function() {
      var res;
      res = this.syncStop();
      if (res === false) {
        return false;
      }
      this.start();
      return true;
    };

    SyncAppend.prototype.syncStop = function() {
      var id, obj, ref;
      if (this.stopped === true) {
        return false;
      }
      ref = this.files;
      for (id in ref) {
        obj = ref[id];
        obj.base.stopped = true;
        obj.base.fsync();
      }
      FS.unlinkSync(this.journalPath);
      if (this.fdJournalDir != null) {
        try {
          FS.fsyncSync(this.fdJournalDir);
        } catch (undefined) {}
      }
      return this.stopped = true;
    };

    SyncAppend.prototype.close = function() {
      var id, obj, ref;
      this.syncStop();
      ref = this.files;
      for (id in ref) {
        obj = ref[id];
        obj.base.close();
      }
      if (this.fdJournalDir != null) {
        FS.closeSync(this.fdJournalDir);
      }
      return this.closed = true;
    };

    SyncAppend.prototype.getFile = function(id) {
      if (this.files[id] != null) {
        return this.files[id].file;
      } else {
        return null;
      }
    };

    SyncAppend.prototype.getFiles = function() {
      var id, obj, ref, res;
      res = {};
      ref = this.files;
      for (id in ref) {
        obj = ref[id];
        res[id] = obj.file;
      }
      return res;
    };

    return SyncAppend;

  })();

  module.exports = SyncAppend;

}).call(this);
